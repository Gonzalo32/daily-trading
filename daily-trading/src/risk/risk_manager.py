"""
Gestor de riesgo del bot de trading
Implementa controles de riesgo y l√≠mites de exposici√≥n
"""

import logging
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta
import pandas as pd
import numpy as np
from config import Config

class RiskManager:
    """Gestor de riesgo para el bot de trading"""
    
    def __init__(self, config: Config):
        self.config = config
        self.logger = logging.getLogger(__name__)
        
        # Estado del gestor de riesgo
        self.daily_pnl = 0.0
        self.daily_trades = 0
        self.max_drawdown = 0.0
        self.peak_balance = 0.0
        self.current_balance = 0.0
        self.risk_metrics = {}
        
        # Historial de operaciones
        self.trade_history = []
        self.daily_history = []
        
    def validate_trade(self, signal: Dict[str, Any], current_positions: List[Dict[str, Any]]) -> bool:
        """Validar si una operaci√≥n cumple con los l√≠mites de riesgo"""
        try:
            # Verificar l√≠mites diarios
            if not self.check_daily_limits(self.daily_pnl, self.daily_trades):
                self.logger.warning("‚ö†Ô∏è L√≠mites diarios alcanzados")
                return False
                
            # Verificar n√∫mero m√°ximo de posiciones
            if len(current_positions) >= self.config.MAX_POSITIONS:
                self.logger.warning("‚ö†Ô∏è N√∫mero m√°ximo de posiciones alcanzado")
                return False
                
            # Verificar exposici√≥n total
            if not self._check_total_exposure(signal, current_positions):
                self.logger.warning("‚ö†Ô∏è Exposici√≥n total excede l√≠mites")
                return False
                
            # Verificar correlaci√≥n entre posiciones
            if not self._check_position_correlation(signal, current_positions):
                self.logger.warning("‚ö†Ô∏è Posici√≥n altamente correlacionada con existentes")
                return False
                
            # Verificar volatilidad del mercado
            if not self._check_market_volatility(signal):
                self.logger.warning("‚ö†Ô∏è Volatilidad del mercado demasiado alta")
                return False
                
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Error validando operaci√≥n: {e}")
            return False
            
    def check_daily_limits(self, daily_pnl: float, daily_trades: int) -> bool:
        """Verificar l√≠mites diarios de p√©rdida y n√∫mero de operaciones"""
        try:
            # Verificar l√≠mite de p√©rdida diaria
            if daily_pnl < -self.config.MAX_DAILY_LOSS * self.current_balance:
                self.logger.warning(f"‚ö†Ô∏è L√≠mite de p√©rdida diaria alcanzado: {daily_pnl:.2f}")
                return False
                
            # Verificar l√≠mite de ganancia diaria (opcional)
            if daily_pnl > self.config.MAX_DAILY_GAIN * self.current_balance:
                self.logger.info(f"‚ÑπÔ∏è L√≠mite de ganancia diaria alcanzado: {daily_pnl:.2f}")
                return False
                
            # Verificar n√∫mero m√°ximo de operaciones diarias
            max_daily_trades = 50  # Configurable
            if daily_trades >= max_daily_trades:
                self.logger.warning(f"‚ö†Ô∏è L√≠mite de operaciones diarias alcanzado: {daily_trades}")
                return False
                
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Error verificando l√≠mites diarios: {e}")
            return False
            
    def should_close_position(self, position: Dict[str, Any], market_data: Dict[str, Any]) -> bool:
        """Determinar si una posici√≥n debe cerrarse por riesgo"""
        try:
            current_price = market_data['price']
            entry_price = position['entry_price']
            stop_loss = position['stop_loss']
            take_profit = position['take_profit']
            
            # Verificar stop loss
            if position['side'] == 'BUY' and current_price <= stop_loss:
                self.logger.info(f"üõë Stop loss activado: {current_price} <= {stop_loss}")
                return True
                
            if position['side'] == 'SELL' and current_price >= stop_loss:
                self.logger.info(f"üõë Stop loss activado: {current_price} >= {stop_loss}")
                return True
                
            # Verificar take profit
            if position['side'] == 'BUY' and current_price >= take_profit:
                self.logger.info(f"üéØ Take profit activado: {current_price} >= {take_profit}")
                return True
                
            if position['side'] == 'SELL' and current_price <= take_profit:
                self.logger.info(f"üéØ Take profit activado: {current_price} <= {take_profit}")
                return True
                
            # Verificar trailing stop (si est√° habilitado)
            if self._check_trailing_stop(position, current_price):
                self.logger.info("üîÑ Trailing stop activado")
                return True
                
            # Verificar tiempo m√°ximo de posici√≥n
            if self._check_max_position_time(position):
                self.logger.info("‚è∞ Tiempo m√°ximo de posici√≥n alcanzado")
                return True
                
            return False
            
        except Exception as e:
            self.logger.error(f"‚ùå Error verificando cierre de posici√≥n: {e}")
            return False
            
    def _check_total_exposure(self, signal: Dict[str, Any], current_positions: List[Dict[str, Any]]) -> bool:
        """Verificar exposici√≥n total del portafolio"""
        try:
            # Calcular exposici√≥n actual
            current_exposure = sum(pos['position_size'] * pos['entry_price'] for pos in current_positions)
            
            # Calcular nueva exposici√≥n
            new_exposure = signal['position_size'] * signal['price']
            
            # Verificar l√≠mite de exposici√≥n total (ej. 50% del capital)
            max_exposure = self.current_balance * 0.5
            total_exposure = current_exposure + new_exposure
            
            if total_exposure > max_exposure:
                self.logger.warning(f"‚ö†Ô∏è Exposici√≥n total excede l√≠mite: {total_exposure:.2f} > {max_exposure:.2f}")
                return False
                
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Error verificando exposici√≥n total: {e}")
            return False
            
    def _check_position_correlation(self, signal: Dict[str, Any], current_positions: List[Dict[str, Any]]) -> bool:
        """Verificar correlaci√≥n entre posiciones"""
        try:
            # Por simplicidad, asumimos que posiciones del mismo s√≠mbolo est√°n correlacionadas
            signal_symbol = signal['symbol']
            
            # Contar posiciones del mismo s√≠mbolo
            same_symbol_positions = [pos for pos in current_positions if pos['symbol'] == signal_symbol]
            
            # L√≠mite de posiciones por s√≠mbolo
            max_positions_per_symbol = 1
            if len(same_symbol_positions) >= max_positions_per_symbol:
                self.logger.warning(f"‚ö†Ô∏è Ya existe posici√≥n para {signal_symbol}")
                return False
                
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Error verificando correlaci√≥n: {e}")
            return False
            
    def _check_market_volatility(self, signal: Dict[str, Any]) -> bool:
        """Verificar volatilidad del mercado"""
        try:
            # Por simplicidad, asumimos que la volatilidad est√° en el signal
            # En una implementaci√≥n real, se calcular√≠a bas√°ndose en ATR o similar
            volatility_threshold = 0.05  # 5%
            
            # Simular verificaci√≥n de volatilidad
            # En implementaci√≥n real, usar√≠amos datos de mercado reales
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Error verificando volatilidad: {e}")
            return False
            
    def _check_trailing_stop(self, position: Dict[str, Any], current_price: float) -> bool:
        """Verificar trailing stop"""
        try:
            if 'trailing_stop' not in position:
                return False
                
            trailing_stop = position['trailing_stop']
            entry_price = position['entry_price']
            
            # Calcular trailing stop din√°mico
            if position['side'] == 'BUY':
                # Para posiciones largas, el trailing stop sube con el precio
                new_trailing_stop = current_price * (1 - self.config.STOP_LOSS_PCT)
                if new_trailing_stop > trailing_stop:
                    position['trailing_stop'] = new_trailing_stop
                    return False
                else:
                    return current_price <= trailing_stop
            else:
                # Para posiciones cortas, el trailing stop baja con el precio
                new_trailing_stop = current_price * (1 + self.config.STOP_LOSS_PCT)
                if new_trailing_stop < trailing_stop:
                    position['trailing_stop'] = new_trailing_stop
                    return False
                else:
                    return current_price >= trailing_stop
                    
        except Exception as e:
            self.logger.error(f"‚ùå Error verificando trailing stop: {e}")
            return False
            
    def _check_max_position_time(self, position: Dict[str, Any]) -> bool:
        """Verificar tiempo m√°ximo de posici√≥n"""
        try:
            if 'entry_time' not in position:
                return False
                
            entry_time = position['entry_time']
            max_position_time = timedelta(hours=4)  # 4 horas m√°ximo
            
            return datetime.now() - entry_time > max_position_time
            
        except Exception as e:
            self.logger.error(f"‚ùå Error verificando tiempo m√°ximo: {e}")
            return False
            
    def update_balance(self, new_balance: float):
        """Actualizar balance actual"""
        self.current_balance = new_balance
        
        # Actualizar peak balance
        if new_balance > self.peak_balance:
            self.peak_balance = new_balance
            
        # Calcular drawdown actual
        current_drawdown = (self.peak_balance - new_balance) / self.peak_balance
        if current_drawdown > self.max_drawdown:
            self.max_drawdown = current_drawdown
            
    def record_trade(self, trade_data: Dict[str, Any]):
        """Registrar operaci√≥n en el historial"""
        try:
            trade_record = {
                'timestamp': datetime.now(),
                'symbol': trade_data['symbol'],
                'action': trade_data['action'],
                'price': trade_data['price'],
                'size': trade_data['position_size'],
                'pnl': trade_data.get('pnl', 0.0),
                'reason': trade_data.get('reason', '')
            }
            
            self.trade_history.append(trade_record)
            
            # Mantener solo los √∫ltimos 1000 trades
            if len(self.trade_history) > 1000:
                self.trade_history = self.trade_history[-1000:]
                
        except Exception as e:
            self.logger.error(f"‚ùå Error registrando operaci√≥n: {e}")
            
    def get_risk_metrics(self) -> Dict[str, Any]:
        """Obtener m√©tricas de riesgo actuales"""
        try:
            # Calcular m√©tricas b√°sicas
            total_trades = len(self.trade_history)
            winning_trades = len([t for t in self.trade_history if t['pnl'] > 0])
            losing_trades = len([t for t in self.trade_history if t['pnl'] < 0])
            
            win_rate = winning_trades / total_trades if total_trades > 0 else 0
            
            # Calcular PnL total
            total_pnl = sum(t['pnl'] for t in self.trade_history)
            
            # Calcular Sharpe ratio (simplificado)
            if total_trades > 1:
                returns = [t['pnl'] for t in self.trade_history]
                sharpe_ratio = np.mean(returns) / np.std(returns) if np.std(returns) > 0 else 0
            else:
                sharpe_ratio = 0
                
            return {
                'daily_pnl': self.daily_pnl,
                'daily_trades': self.daily_trades,
                'total_trades': total_trades,
                'win_rate': win_rate,
                'total_pnl': total_pnl,
                'max_drawdown': self.max_drawdown,
                'sharpe_ratio': sharpe_ratio,
                'current_balance': self.current_balance,
                'peak_balance': self.peak_balance
            }
            
        except Exception as e:
            self.logger.error(f"‚ùå Error calculando m√©tricas de riesgo: {e}")
            return {}
            
    def reset_daily_metrics(self):
        """Reiniciar m√©tricas diarias"""
        self.daily_pnl = 0.0
        self.daily_trades = 0
        self.logger.info("üîÑ M√©tricas diarias reiniciadas")
        
    def emergency_stop(self):
        """Parada de emergencia del trading"""
        self.logger.critical("üö® PARADA DE EMERGENCIA ACTIVADA")
        # Aqu√≠ se implementar√≠a la l√≥gica para cerrar todas las posiciones
        # y detener el trading inmediatamente
